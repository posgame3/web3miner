{"version":3,"file":"ccip-BM62U4d0.js","sources":["../../node_modules/viem/_esm/utils/abi/decodeFunctionData.js","../../node_modules/viem/_esm/utils/abi/encodeErrorResult.js","../../node_modules/viem/_esm/utils/abi/encodeFunctionResult.js","../../node_modules/viem/_esm/utils/ens/localBatchGatewayRequest.js","../../node_modules/viem/_esm/utils/address/isAddressEqual.js","../../node_modules/viem/_esm/errors/ccip.js","../../node_modules/viem/_esm/utils/ccip.js"],"sourcesContent":["import { AbiFunctionSignatureNotFoundError } from '../../errors/abi.js';\nimport { slice } from '../data/slice.js';\nimport { toFunctionSelector, } from '../hash/toFunctionSelector.js';\nimport { decodeAbiParameters, } from './decodeAbiParameters.js';\nimport { formatAbiItem } from './formatAbiItem.js';\nexport function decodeFunctionData(parameters) {\n    const { abi, data } = parameters;\n    const signature = slice(data, 0, 4);\n    const description = abi.find((x) => x.type === 'function' &&\n        signature === toFunctionSelector(formatAbiItem(x)));\n    if (!description)\n        throw new AbiFunctionSignatureNotFoundError(signature, {\n            docsPath: '/docs/contract/decodeFunctionData',\n        });\n    return {\n        functionName: description.name,\n        args: ('inputs' in description &&\n            description.inputs &&\n            description.inputs.length > 0\n            ? decodeAbiParameters(description.inputs, slice(data, 4))\n            : undefined),\n    };\n}\n//# sourceMappingURL=decodeFunctionData.js.map","import { AbiErrorInputsNotFoundError, AbiErrorNotFoundError, } from '../../errors/abi.js';\nimport { concatHex } from '../data/concat.js';\nimport { toFunctionSelector, } from '../hash/toFunctionSelector.js';\nimport { encodeAbiParameters, } from './encodeAbiParameters.js';\nimport { formatAbiItem } from './formatAbiItem.js';\nimport { getAbiItem } from './getAbiItem.js';\nconst docsPath = '/docs/contract/encodeErrorResult';\nexport function encodeErrorResult(parameters) {\n    const { abi, errorName, args } = parameters;\n    let abiItem = abi[0];\n    if (errorName) {\n        const item = getAbiItem({ abi, args, name: errorName });\n        if (!item)\n            throw new AbiErrorNotFoundError(errorName, { docsPath });\n        abiItem = item;\n    }\n    if (abiItem.type !== 'error')\n        throw new AbiErrorNotFoundError(undefined, { docsPath });\n    const definition = formatAbiItem(abiItem);\n    const signature = toFunctionSelector(definition);\n    let data = '0x';\n    if (args && args.length > 0) {\n        if (!abiItem.inputs)\n            throw new AbiErrorInputsNotFoundError(abiItem.name, { docsPath });\n        data = encodeAbiParameters(abiItem.inputs, args);\n    }\n    return concatHex([signature, data]);\n}\n//# sourceMappingURL=encodeErrorResult.js.map","import { AbiFunctionNotFoundError, AbiFunctionOutputsNotFoundError, InvalidArrayError, } from '../../errors/abi.js';\nimport { encodeAbiParameters, } from './encodeAbiParameters.js';\nimport { getAbiItem } from './getAbiItem.js';\nconst docsPath = '/docs/contract/encodeFunctionResult';\nexport function encodeFunctionResult(parameters) {\n    const { abi, functionName, result } = parameters;\n    let abiItem = abi[0];\n    if (functionName) {\n        const item = getAbiItem({ abi, name: functionName });\n        if (!item)\n            throw new AbiFunctionNotFoundError(functionName, { docsPath });\n        abiItem = item;\n    }\n    if (abiItem.type !== 'function')\n        throw new AbiFunctionNotFoundError(undefined, { docsPath });\n    if (!abiItem.outputs)\n        throw new AbiFunctionOutputsNotFoundError(abiItem.name, { docsPath });\n    const values = (() => {\n        if (abiItem.outputs.length === 0)\n            return [];\n        if (abiItem.outputs.length === 1)\n            return [result];\n        if (Array.isArray(result))\n            return result;\n        throw new InvalidArrayError(result);\n    })();\n    return encodeAbiParameters(abiItem.outputs, values);\n}\n//# sourceMappingURL=encodeFunctionResult.js.map","import { batchGatewayAbi } from '../../constants/abis.js';\nimport { solidityError } from '../../constants/solidity.js';\nimport { decodeFunctionData } from '../abi/decodeFunctionData.js';\nimport { encodeErrorResult } from '../abi/encodeErrorResult.js';\nimport { encodeFunctionResult } from '../abi/encodeFunctionResult.js';\nexport const localBatchGatewayUrl = 'x-batch-gateway:true';\nexport async function localBatchGatewayRequest(parameters) {\n    const { data, ccipRequest } = parameters;\n    const { args: [queries], } = decodeFunctionData({ abi: batchGatewayAbi, data });\n    const failures = [];\n    const responses = [];\n    await Promise.all(queries.map(async (query, i) => {\n        try {\n            responses[i] = await ccipRequest(query);\n            failures[i] = false;\n        }\n        catch (err) {\n            failures[i] = true;\n            responses[i] = encodeError(err);\n        }\n    }));\n    return encodeFunctionResult({\n        abi: batchGatewayAbi,\n        functionName: 'query',\n        result: [failures, responses],\n    });\n}\nfunction encodeError(error) {\n    if (error.name === 'HttpRequestError' && error.status)\n        return encodeErrorResult({\n            abi: batchGatewayAbi,\n            errorName: 'HttpError',\n            args: [error.status, error.shortMessage],\n        });\n    return encodeErrorResult({\n        abi: [solidityError],\n        errorName: 'Error',\n        args: ['shortMessage' in error ? error.shortMessage : error.message],\n    });\n}\n//# sourceMappingURL=localBatchGatewayRequest.js.map","import { InvalidAddressError, } from '../../errors/address.js';\nimport { isAddress } from './isAddress.js';\nexport function isAddressEqual(a, b) {\n    if (!isAddress(a, { strict: false }))\n        throw new InvalidAddressError({ address: a });\n    if (!isAddress(b, { strict: false }))\n        throw new InvalidAddressError({ address: b });\n    return a.toLowerCase() === b.toLowerCase();\n}\n//# sourceMappingURL=isAddressEqual.js.map","import { stringify } from '../utils/stringify.js';\nimport { BaseError } from './base.js';\nimport { getUrl } from './utils.js';\nexport class OffchainLookupError extends BaseError {\n    constructor({ callbackSelector, cause, data, extraData, sender, urls, }) {\n        super(cause.shortMessage ||\n            'An error occurred while fetching for an offchain result.', {\n            cause,\n            metaMessages: [\n                ...(cause.metaMessages || []),\n                cause.metaMessages?.length ? '' : [],\n                'Offchain Gateway Call:',\n                urls && [\n                    '  Gateway URL(s):',\n                    ...urls.map((url) => `    ${getUrl(url)}`),\n                ],\n                `  Sender: ${sender}`,\n                `  Data: ${data}`,\n                `  Callback selector: ${callbackSelector}`,\n                `  Extra data: ${extraData}`,\n            ].flat(),\n            name: 'OffchainLookupError',\n        });\n    }\n}\nexport class OffchainLookupResponseMalformedError extends BaseError {\n    constructor({ result, url }) {\n        super('Offchain gateway response is malformed. Response data must be a hex value.', {\n            metaMessages: [\n                `Gateway URL: ${getUrl(url)}`,\n                `Response: ${stringify(result)}`,\n            ],\n            name: 'OffchainLookupResponseMalformedError',\n        });\n    }\n}\nexport class OffchainLookupSenderMismatchError extends BaseError {\n    constructor({ sender, to }) {\n        super('Reverted sender address does not match target contract address (`to`).', {\n            metaMessages: [\n                `Contract address: ${to}`,\n                `OffchainLookup sender address: ${sender}`,\n            ],\n            name: 'OffchainLookupSenderMismatchError',\n        });\n    }\n}\n//# sourceMappingURL=ccip.js.map","import { call } from '../actions/public/call.js';\nimport { OffchainLookupError, OffchainLookupResponseMalformedError, OffchainLookupSenderMismatchError, } from '../errors/ccip.js';\nimport { HttpRequestError, } from '../errors/request.js';\nimport { decodeErrorResult } from './abi/decodeErrorResult.js';\nimport { encodeAbiParameters } from './abi/encodeAbiParameters.js';\nimport { isAddressEqual } from './address/isAddressEqual.js';\nimport { concat } from './data/concat.js';\nimport { isHex } from './data/isHex.js';\nimport { localBatchGatewayRequest, localBatchGatewayUrl, } from './ens/localBatchGatewayRequest.js';\nimport { stringify } from './stringify.js';\nexport const offchainLookupSignature = '0x556f1830';\nexport const offchainLookupAbiItem = {\n    name: 'OffchainLookup',\n    type: 'error',\n    inputs: [\n        {\n            name: 'sender',\n            type: 'address',\n        },\n        {\n            name: 'urls',\n            type: 'string[]',\n        },\n        {\n            name: 'callData',\n            type: 'bytes',\n        },\n        {\n            name: 'callbackFunction',\n            type: 'bytes4',\n        },\n        {\n            name: 'extraData',\n            type: 'bytes',\n        },\n    ],\n};\nexport async function offchainLookup(client, { blockNumber, blockTag, data, to, }) {\n    const { args } = decodeErrorResult({\n        data,\n        abi: [offchainLookupAbiItem],\n    });\n    const [sender, urls, callData, callbackSelector, extraData] = args;\n    const { ccipRead } = client;\n    const ccipRequest_ = ccipRead && typeof ccipRead?.request === 'function'\n        ? ccipRead.request\n        : ccipRequest;\n    try {\n        if (!isAddressEqual(to, sender))\n            throw new OffchainLookupSenderMismatchError({ sender, to });\n        const result = urls.includes(localBatchGatewayUrl)\n            ? await localBatchGatewayRequest({\n                data: callData,\n                ccipRequest: ccipRequest_,\n            })\n            : await ccipRequest_({ data: callData, sender, urls });\n        const { data: data_ } = await call(client, {\n            blockNumber,\n            blockTag,\n            data: concat([\n                callbackSelector,\n                encodeAbiParameters([{ type: 'bytes' }, { type: 'bytes' }], [result, extraData]),\n            ]),\n            to,\n        });\n        return data_;\n    }\n    catch (err) {\n        throw new OffchainLookupError({\n            callbackSelector,\n            cause: err,\n            data,\n            extraData,\n            sender,\n            urls,\n        });\n    }\n}\nexport async function ccipRequest({ data, sender, urls, }) {\n    let error = new Error('An unknown error occurred.');\n    for (let i = 0; i < urls.length; i++) {\n        const url = urls[i];\n        const method = url.includes('{data}') ? 'GET' : 'POST';\n        const body = method === 'POST' ? { data, sender } : undefined;\n        const headers = method === 'POST' ? { 'Content-Type': 'application/json' } : {};\n        try {\n            const response = await fetch(url.replace('{sender}', sender.toLowerCase()).replace('{data}', data), {\n                body: JSON.stringify(body),\n                headers,\n                method,\n            });\n            let result;\n            if (response.headers.get('Content-Type')?.startsWith('application/json')) {\n                result = (await response.json()).data;\n            }\n            else {\n                result = (await response.text());\n            }\n            if (!response.ok) {\n                error = new HttpRequestError({\n                    body,\n                    details: result?.error\n                        ? stringify(result.error)\n                        : response.statusText,\n                    headers: response.headers,\n                    status: response.status,\n                    url,\n                });\n                continue;\n            }\n            if (!isHex(result)) {\n                error = new OffchainLookupResponseMalformedError({\n                    result,\n                    url,\n                });\n                continue;\n            }\n            return result;\n        }\n        catch (err) {\n            error = new HttpRequestError({\n                body,\n                details: err.message,\n                url,\n            });\n        }\n    }\n    throw error;\n}\n//# sourceMappingURL=ccip.js.map"],"names":["decodeFunctionData","parameters","abi","data","signature","slice","description","x","toFunctionSelector","formatAbiItem","AbiFunctionSignatureNotFoundError","decodeAbiParameters","docsPath","encodeErrorResult","errorName","args","abiItem","item","getAbiItem","AbiErrorNotFoundError","definition","AbiErrorInputsNotFoundError","encodeAbiParameters","concatHex","encodeFunctionResult","functionName","result","AbiFunctionNotFoundError","AbiFunctionOutputsNotFoundError","values","InvalidArrayError","localBatchGatewayUrl","localBatchGatewayRequest","ccipRequest","queries","batchGatewayAbi","failures","responses","query","i","err","encodeError","error","solidityError","isAddressEqual","a","b","isAddress","InvalidAddressError","OffchainLookupError","BaseError","callbackSelector","cause","extraData","sender","urls","_a","url","getUrl","OffchainLookupResponseMalformedError","stringify","OffchainLookupSenderMismatchError","to","offchainLookupSignature","offchainLookupAbiItem","offchainLookup","client","blockNumber","blockTag","decodeErrorResult","callData","ccipRead","ccipRequest_","data_","call","concat","method","body","headers","response","HttpRequestError","isHex"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6]}